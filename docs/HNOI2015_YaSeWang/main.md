# HNOI2015 亚瑟王

??? Quote "题面"

    ## 题面

    ### 链接

    [Luogu P3239](https://www.luogu.com.cn/problem/P3239)

    [darkbzoj](https://darkbzoj.tk/problem/4008)

    ### 题目描述

    小 K 不慎被 LL 邪教洗脑了，洗脑程度深到他甚至想要从亚瑟王邪教中脱坑。他决定，在脱坑之前，最后再来打一盘亚瑟王。既然是最后一战，就一定要打得漂亮。众所周知，亚瑟王是一个看脸的游戏，技能的发动都是看概率的。

    作为一个非洲人，同时作为一个前 OIer，小 K 自然是希望最大化造成伤害的期望值。但他已经多年没写过代码，连 Spaly 都敲不对了，因此，希望你能帮帮小 K，让他感受一下当欧洲人是怎样的体验。

    本题中我们将考虑游戏的一个简化版模型。 玩家有一套卡牌，共 $n$ 张。游戏时，玩家将 $n$ 张卡牌排列成某种顺序，排列后将卡牌按从前往后依次编号为 $1 -  n$。本题中，顺序已经确定，即为输入的顺序。每张卡牌都有一个技能。第 $i$ 张卡牌的技能发动概率为 $p_i$，如果成功发动，则会对敌方造成 $d_i$ 点伤害。也只有通过发动技能，卡牌才能对敌方造成伤害。基于现实因素以及小 K 非洲血统的考虑，$p_i$ 不会为 $0$，也不会为 $1$，即 $0 < p_i < 1$。 一局游戏一共有 $r$ 轮。在每一轮中，系统将从第一张卡牌开始，按照顺序依次考虑每张卡牌。在一轮中，对于依次考虑的每一张卡牌：

    1. 如果这张卡牌在这一局游戏中已经发动过技能，则

        1.1. 如果这张卡牌不是最后一张，则跳过之（考虑下一张卡牌）； 否则（是最后一张），结束这一轮游戏。

    2. 否则（这张卡牌在这一局游戏中没有发动过技能），设这张卡牌为第 $i$ 张

        2.1. 将其以 $p_i$ 的概率发动技能。

        2.2. 如果技能发动，则对敌方造成 $d_i$ 点伤害，并结束这一轮。

        2.3. 如果这张卡牌已经是最后一张（即 $i$ 等于 $n$），则结束这一轮；否则，考虑下一张卡牌。

        请帮助小 K 求出这一套卡牌在一局游戏中能造成的伤害的期望值。

    ### 输入格式

    输入文件的第一行包含一个整数 $T$，代表测试数据组数。

    接下来一共 $T$ 组数据。

    每组数据的第一行包含两个用空格分开的整数 $n$ 和 $r$，分别代表卡牌的张数和游戏的轮数。

    接下来 $n$ 行，每行包含一个实数和一个整数，由空格隔开，描述一张卡牌。第 $i$ 行的两个数为 $p_i$ 和 $d_i$，分别代表第 $i$ 张卡牌技能发动的概率（实数）和技能发动造成的伤害（整数）。保证 $p_i$ 最多包含 $4$ 位小数，且为一个合法的概率。

    ### 输出格式

    对于每组数据，输出一行，包含一个实数，为这套卡牌在这一局游戏中造成的伤害的期望值。对于每一行输出，只有当你的输出和标准答案的相对误差不超过 $10^{-8}$ 时——即 $\frac{|a-o|}{a} \leq 10^{-8}$ 时(其中 $a$ 是标准答案， $o$ 是输出)，你的输出才会被判为正确。建议输出 $10$ 位小数。

    ### 输入样例

    ```text
    1
    3 2
    0.5000 2
    0.3000 3
    0.9000 1
    ```

    ### 输出样例

    ```text
    3.2660250000
    ```

    ### 说明/提示

    一共有 $13$ 种可能的情况：

    1. 第一轮中，第 $1$ 张卡牌发动技能；第二轮中，第 $2$ 张卡牌发动技能；
        概率为 $0.15$，伤害为 $5$。

    1. 第一轮中，第 $1$ 张卡牌发动技能；第二轮中，第 $3$ 张卡牌发动技能；
        概率为 $0.315$，伤害为 $3$。

    1. 第一轮中，第 $1$ 张卡牌发动技能；第二轮不发动技能；
        概率为 $0.035$，伤害为 $2$。

    1. 第一轮中，第 $2$ 张卡牌发动技能；第二轮中，第 $1$ 张卡牌发动技能；
        概率为 $0.075$，伤害为 $5$。

    1. 第一轮中，第 $2$ 张卡牌发动技能；第二轮中，第 $3$ 张卡牌发动技能；
        概率为 $0.0675$，伤害为 $4$。

    1. 第一轮中，第 $2$ 张卡牌发动技能；第二轮不发动技能；
        概率为 $0.0075$，伤害为 $3$。

    1. 第一轮中，第 $3$ 张卡牌发动技能；第二轮中，第 $1$ 张卡牌发动技能；
        概率为 $0.1575$，伤害为 $3$。

    1. 第一轮中，第 $3$ 张卡牌发动技能；第二轮中，第 $2$ 张卡牌发动技能；
        概率为 $0.04725$，伤害为 $4$。

    1. 第一轮中，第 $3$ 张卡牌发动技能；第二轮不发动技能；
        概率为 $0.11025$，伤害为 $1$。

    1. 第一轮不发动技能；第二轮中，第 $1$ 张卡牌发动技能；
        概率为 $0.0175$，伤害为 $2$。

    1. 第一轮不发动技能；第二轮中，第 $2$ 张卡牌发动技能；
        概率为 $0.00525$，伤害为 $3$。

    1. 第一轮不发动技能；第二轮中，第 $3$ 张卡牌发动技能；
        概率为 0.011025，伤害为 $1$。

    1. 第一轮不发动技能；第二轮亦不发动技能；
        概率为 $0.001225$，伤害为 $0$。

    造成伤害的期望值为概率与对应伤害乘积之和，为 $3.266025$。

    对于所有测试数据，$1 \leq T \leq 444， 1 \leq n \leq 220， 0 \leq r \leq 132， 0 < p_i < 1， 0 \leq d_i \leq 1000$。

    除非备注中有特殊说明，数据中 $p_i$ 与 $d_i$ 均为随机生成。

    请注意可能存在的实数精度问题，并采取适当措施。

    本题使用 `special_judge`。

## 题解

概率 dp

首先，设第 $i$ 卡牌发动技能的概率为 $f_i$，所有卡牌造成的总伤害的期望为 $E_d$。

那么，这张卡牌造成的伤害即为 $f_i d_i$。（$d$ 为原题中的伤害）

由于数学期望的线性性质[^数学期望的线性性质] $E(X + Y) = E(X) + E(Y)$，可知：
$$
E_d = \sum_{i=1}^n f_i d_i
$$
那么，这题的目标即为求 $f_i$。

**先考虑 $f_1$**

显然，$1 - p_1$ 为 $1$ 号卡牌不发动的概率，因为

> 1. 如果这张卡牌在这一局游戏中已经发动过技能，则
> 
>   1.1. 如果这张卡牌不是最后一张，则跳过之（考虑下一张卡牌）； 否则（是最后一张），结束这一轮游戏。

所以 $1$ 号牌一直不出的概率为 $(1-p_1)^r$。（$r$ 为原题中游戏的轮数）

说明 $1$ 号牌发动的概率 $f_1 = 1 - (1 - p_1)^r$。

**再考虑 $f_2$**

分类讨论：

1. 假如 $1$ 号卡牌发动了技能

   $$
   f_2 = 1 - (1 - p_2)^{r - 1}
   $$

   因为 $1$ 号卡牌发动了技能，那么：

   > 2. 否则（这张卡牌在这一局游戏中没有发动过技能），设这张卡牌为第 $i$ 张
   >
   >   2.1. 将其以 $p_i$ 的概率发动技能。
   >
   >   2.2 如果技能发动，则对敌方造成 $d_i$ 点伤害，并结束这一轮。

   第一张牌发动了技能，根据 `2.2` 结束了这一轮，即与第二张牌发动的概率无关，所以这次为发动的概率不算在 $f_2$ 中，所以得到指数为 $r - 1$。

2. 假如 $1$ 号卡牌没有发动技能

   同 $f_1$ 的情况，

   $$
   f_2 = 1 - (1 - p_2)^r
   $$

**再考虑接下来的 $f_i$**

假设在第 $i$ 张牌尝试发动前已有 $j$ 张牌成功发动了技能，那么：
$$
f_i = 1 - (1 - p_i)^{r-j}
$$
考虑到数据较小，

> $1 \leq T \leq 444， 1 \leq n \leq 220， 0 \leq r \leq 132， 0 < p_i < 1， 0 \leq d_i \leq 1000$

要处理 $f_i$ ，可以用动态规划。

设 $\operatorname{dp}_{i,j}$ 表示前 $i$ 张牌中，有 $j$ 张发动了技能的概率。

分类讨论：

1. 第 $i$ 张牌发动了技能

   1. 因为有牌发动了技能，所以要保证 $j > 0$

   2. 求状态转移方程

      不难看出，前 $i$ 张牌中，有 $j$ 张发动了技能的概率，应为前 $i - 1$ 张牌中，有 $j - 1$ 张发动了技能的概率乘上第 $i$ 张牌**发动**的概率。

      由前文推导到的 $\small{f_i = 1 - (1 - p_i)^{r-j}}$ 可知第 $i$ 张牌不发动的概率应该是 $\small{f_i = 1 - (1 - p_i)^{r-j}}$ 但已经确定这张牌会发动，所以其概率实际为 $f_i = 1 - (1 - p_i)^{r-j}$。

      得到转移方程 ①：

$$
    \operatorname{dp}_{i,j} = \operatorname{dp}_{i-1,j-1} \cdot (1 - (1 - p_i)^{r - j + 1})\quad(j > 0)
$$

1. 第 $i$ 张牌没有发动技能

   1. 因为第 $i$ 张牌没有发动技能，所以 $j \leq i - 1 \iff i \neq j$。

   1. 求状态转移方程

      不难看出，前 $i$ 张牌中，有 $j$ 张发动了技能的概率，应为前 $i - 1$ 张牌中，有 $j$ 张发动了技能的概率乘上第 $i$ 张牌**不发动**的概率。

      第 $i$ 张牌不发动的概率就为 $(1 - p_i) ^ {r - j}$。

      得出状态转移方程 ②：

$$
    \operatorname{dp}_{i,j} = \operatorname{dp}_{i-1,j} \cdot (1 - p_i)^{r - j}\quad(i \neq j)
$$

用动态规划即可求出 $\operatorname{dp}$。

求出了 $\operatorname{dp}$，要求 $f$。

显然，发动第 $i$ 张牌的概率为前 $i-1$ 张牌中，有 $j$ 张发动了技能的概率乘上第 $i$ 张牌发动的概率的和。（$j\in\{x \mid 0 \leq x \leq i - 1, x\in\mathbb{Z} \}$）
$$
    f_i = \sum_{j=0}^{i -1} \operatorname{dp}_{i - 1, j} \cdot (1 - (1 - p_i)^{r - j})
$$

求出了 $f$，即可求出 $E_d$。

## 代码

```cpp
#include <iostream>
#include <cstring>
#include <iomanip>
#include <cmath>

const int MAX_N = 4e2;

double p[MAX_N];
int d[MAX_N];

double dp[MAX_N][MAX_N];
double f[MAX_N];

double Pw[MAX_N][MAX_N];

int main()
{
    int T;
    std::cin >> T;

    for (int t = 0; t < T; t++)
    {
        // Init
        std::memset(dp, 0, sizeof(dp));
        std::memset(f, 0, sizeof(f));

        int n, r;
        std::cin >> n >> r;

        for (int i = 1; i <= n; i++)
            std::cin >> p[i] >> d[i];

        // Init
        dp[1][0] = std::pow(1 - p[1], r);
        dp[1][1] = 1 - dp[1][0];
        f[1] = dp[1][1];

        // Get dp
        for (int i = 2; i <= n; i++)
        {
            for (int j = 0; j <= std::min(i, r); j++)
            {
                if (j > 0)
                    // f[i][j] = f[i - 1][j - 1] * (1 - (1 - p[i]) ^ (r - j + 1))  (j != 0) ==> do damage from i
                    dp[i][j] += dp[i - 1][j - 1] * (1 - std::pow(1 - p[i], r - j + 1));
                if (i != j)
                    // f[i][j] = f[i - 1][j] * (1 - p[i]) ^ (r - j)  (i != j) ==> no damage from i
                    dp[i][j] += dp[i - 1][j] * std::pow(1 - p[i], r - j);
            }
        }

        // Get f
        for (int i = 2; i <= n; i++)
            for (int j = 0; j <= std::min(i - 1, r); j++)
                f[i] += dp[i - 1][j] * (1 - std::pow(1 - p[i], r - j));

        // Get ans
        double ans = 0;
        for (int i = 1; i <= n; i++)
            ans += f[i] * d[i];

        std::cout << std::fixed << std::setprecision(10) << ans << "\n";
    }

    return 0;
}
```

## 参考

[^数学期望的线性性质]:[如何理解数学期望的线性性质？](https://www.zhihu.com/question/55355570)
